#!/usr/bin/env bash
set -euo pipefail

DEFAULT_SCAN=8
DEFAULT_BROWSER="auto"
DEFAULT_OUT="./in/urls.tsv"

DEFAULT_TITLE_W=70
DEFAULT_URL_W=80

VERBOSE=0
PRETTY=0
DRY_RUN=0
JSON=0

SCAN="$DEFAULT_SCAN"
BROWSER="$DEFAULT_BROWSER"
OUTFILE="$DEFAULT_OUT"
TITLE_W="$DEFAULT_TITLE_W"
URL_W="$DEFAULT_URL_W"

# R6 tecnico: cookie file (Netscape) con priorità su --browser
COOKIES_FILE=""

FEED_URL="https://www.youtube.com/feed/subscriptions"
have_deno=0

TMP=""
CLEAN_TMP=""
OUT_TMP=""
YTDLP_ERR=""

# R4 SSOT: whitelist browser + hint identico (ordine e punteggiatura invariati)
SUPPORTED_BROWSERS=(brave chrome chromium edge firefox opera safari vivaldi whale)
SUPPORTED_BROWSERS_HINT="brave, chrome, chromium, edge, firefox, opera, safari, vivaldi, whale"

usage() {
  cat <<'EOF'
gyte-digest — genera una mini “rassegna” dal feed YouTube Subscriptions.

Output (TSV):
  #id<TAB>title<TAB>url
  001<TAB>...<TAB>https://www.youtube.com/watch?v=...

Opzioni:
  --scan N         Quanti video prendere (default: 8)

  --cookies FILE   Usa un file cookies in formato Netscape (priorità su --browser).
                   Se presente, gyte-digest usa: yt-dlp --cookies FILE

  --browser NAME   Browser per cookies-from-browser (default: auto)
                   NAME supportati: brave, chrome, chromium, edge, firefox, opera, safari, vivaldi, whale
                   Speciale: auto (prova in ordine finché trova una sessione YouTube valida)

  --out FILE       File TSV da scrivere (default: ./in/urls.tsv)
  --pretty         Stampa una tabella "carina" su stdout (colonne auto + troncamento). Il TSV viene comunque salvato in --out
  --json           Stampa JSON Lines su stdout (un oggetto per riga). Il TSV viene comunque salvato in --out
  --dry-run        NON esegue yt-dlp: stampa il comando che verrebbe eseguito
  --verbose        Abilita log su stderr
  -h, --help       Mostra questo help

Note:
- Richiede yt-dlp.
- Feed: https://www.youtube.com/feed/subscriptions
EOF
}

ts() { date "+%Y-%m-%d %H:%M:%S"; }
log() { if (( VERBOSE )); then echo "[gyte-digest] $(ts) $*" >&2; fi; }
die() { echo "ERRORE: $*" >&2; exit 1; }

need() { command -v "$1" >/dev/null 2>&1 || die "comando non trovato: $1"; }
is_int() { [[ "${1:-}" =~ ^[0-9]+$ ]]; }

sanitize_scan() {
  local n="$1"
  if ! is_int "$n"; then echo "$DEFAULT_SCAN"; return 0; fi
  if (( n < 1 )); then echo "$DEFAULT_SCAN"; return 0; fi
  if (( n > 200 )); then echo 200; return 0; fi
  echo "$n"
}

auto_pretty_widths() {
  local cols overhead min_title min_url max_title max_url
  overhead=9
  min_title=20
  min_url=40
  max_title=120
  max_url=160

  cols="$(tput cols 2>/dev/null || true)"
  if ! is_int "${cols:-}"; then cols=0; fi

  if (( cols < 60 )); then
    TITLE_W="$DEFAULT_TITLE_W"
    URL_W="$DEFAULT_URL_W"
    return 0
  fi

  local url_candidate title_candidate
  url_candidate="$DEFAULT_URL_W"

  local url_max_allowed=$(( cols - overhead - min_title ))
  if (( url_candidate > url_max_allowed )); then url_candidate="$url_max_allowed"; fi
  if (( url_candidate < min_url )); then url_candidate="$min_url"; fi

  title_candidate=$(( cols - overhead - url_candidate ))

  if (( title_candidate < min_title )); then
    url_candidate=$(( cols - overhead - min_title ))
    if (( url_candidate < 10 )); then url_candidate=10; fi
    title_candidate=$(( cols - overhead - url_candidate ))
  fi

  if (( title_candidate > max_title )); then title_candidate="$max_title"; fi
  if (( url_candidate > max_url )); then url_candidate="$max_url"; fi

  TITLE_W="$title_candidate"
  URL_W="$url_candidate"
  log "pretty widths: cols=$cols title_w=$TITLE_W url_w=$URL_W"
}

pretty_print() {
  local file="$1" w_title="$2" w_url="$3"
  awk -F'\t' -v WT="$w_title" -v WU="$w_url" '
    function trunc(s, w) {
      gsub(/\r$/, "", s);
      gsub(/[[:space:]]+$/, "", s);
      gsub(/^[[:space:]]+/, "", s);
      if (w < 4) return substr(s, 1, w);
      if (length(s) > w) return substr(s, 1, w-3) "...";
      return s;
    }
    function rep(ch, n,   i, s) {
      s=""; for (i=0; i<n; i++) s = s ch; return s;
    }
    BEGIN {
      printf "%3s | %-*s | %-*s\n", "ID", WT, "Titolo", WU, "URL";
      printf "%s-+-%s-+-%s\n", rep("-",3), rep("-",WT), rep("-",WU);
    }
    NR==1 { next }
    {
      printf "%3s | %-*s | %-*s\n", $1, WT, trunc($2, WT), WU, trunc($3, WU);
    }
  ' "$file"
}

json_print() {
  local file="$1"
  awk -F'\t' '
    function jesc(s,   out,i,c) {
      out=""
      for (i=1; i<=length(s); i++) {
        c=substr(s,i,1)
        if (c=="\\") out=out "\\\\"
        else if (c=="\"") out=out "\\\""
        else if (c=="\b") out=out "\\b"
        else if (c=="\f") out=out "\\f"
        else if (c=="\n") out=out "\\n"
        else if (c=="\r") out=out "\\r"
        else if (c=="\t") out=out "\\t"
        else out=out c
      }
      return out
    }
    NR==1 { next }
    {
      id=$1; title=$2; url=$3
      printf "{\"id\":\"%s\",\"title\":\"%s\",\"url\":\"%s\"}\n", jesc(id), jesc(title), jesc(url)
    }
  ' "$file"
}

parse_args() {
  while (( $# > 0 )); do
    case "$1" in
      --scan) (( $# >= 2 )) || die "--scan richiede un numero"; SCAN="$(sanitize_scan "$2")"; shift 2;;
      --scan=*) SCAN="$(sanitize_scan "${1#*=}")"; shift;;

      --cookies) (( $# >= 2 )) || die "--cookies richiede un path"; COOKIES_FILE="$2"; shift 2;;
      --cookies=*) COOKIES_FILE="${1#*=}"; shift;;

      --browser) (( $# >= 2 )) || die "--browser richiede un argomento"; BROWSER="$2"; shift 2;;
      --browser=*) BROWSER="${1#*=}"; shift;;

      --out) (( $# >= 2 )) || die "--out richiede un path"; OUTFILE="$2"; shift 2;;
      --out=*) OUTFILE="${1#*=}"; shift;;

      --pretty) PRETTY=1; shift;;
      --json) JSON=1; shift;;
      --dry-run) DRY_RUN=1; shift;;
      --verbose) VERBOSE=1; shift;;
      -h|--help) usage; exit 0;;
      *) die "opzione non riconosciuta: $1 (prova --help)";;
    esac
  done
}

validate_flags() {
  if (( PRETTY && JSON )); then
    die "--pretty e --json sono mutuamente esclusivi"
  fi
}

validate_cookies_file_or_die() {
  [[ -n "${COOKIES_FILE:-}" ]] || return 0

  if [[ ! -r "$COOKIES_FILE" ]]; then
    die "--cookies non leggibile o inesistente: $COOKIES_FILE"
  fi

  # Heuristica minima: evitare file completamente non correlati (es. cookie di altri siti)
  if ! grep -Eqi 'youtube\.com|google\.com|accounts\.google' "$COOKIES_FILE"; then
    echo "ERRORE: il file --cookies non sembra contenere cookie Google/YouTube: $COOKIES_FILE" >&2
    echo "Hint: esporta/rigenera un cookie file con sessione YouTube valida e riprova." >&2
    exit 1
  fi

  # R7: validazione sessione (cookie "auth-like"), per fallire subito se file anonimo
  if ! grep -Eqi 'SAPISID|APISID|__Secure-3PAPISID|__Secure-1PAPISID|__Secure-3PSID|__Secure-1PSID|(^|[[:space:]])SID([[:space:]]|$)|(^|[[:space:]])HSID([[:space:]]|$)|(^|[[:space:]])SSID([[:space:]]|$)' "$COOKIES_FILE"; then
    echo "ERRORE: il file --cookies non contiene una sessione YouTube valida (sembra anonimo): $COOKIES_FILE" >&2
    echo "Hint: fai login su YouTube e rigenera il file cookies, poi riprova." >&2
    echo "Esempio (Brave):" >&2
    echo "  yt-dlp --cookies-from-browser brave --cookies \"$COOKIES_FILE\" --skip-download \"$FEED_URL\" >/dev/null" >&2
    exit 1
  fi
}

is_supported_browser() {
  local b="${1:-}"
  local x
  for x in "${SUPPORTED_BROWSERS[@]}"; do
    [[ "$b" == "$x" ]] && return 0
  done
  return 1
}

validate_browser_or_die() {
  # Se uso --cookies, --browser viene ignorato (priorità su cookie file)
  if [[ -n "${COOKIES_FILE:-}" ]]; then
    return 0
  fi

  local b="${BROWSER:-}"
  if [[ "$b" == "auto" ]]; then
    return 0
  fi
  if is_supported_browser "$b"; then
    return 0
  fi
  echo "ERRORE: browser non supportato per --cookies-from-browser: \"$BROWSER\"." >&2
  echo "Hint: usa uno tra: $SUPPORTED_BROWSERS_HINT" >&2
  exit 1
}

detect_js_runtime() {
  have_deno=0
  if command -v deno >/dev/null 2>&1; then
    have_deno=1
  fi
}

print_dry_run_cmd_for_browser() {
  local b="$1"
  echo "yt-dlp \\"
  if (( have_deno )); then
    echo "  --js-runtimes deno \\"
  fi
  echo "  --cookies-from-browser \"$b\" \\"
  echo "  --extractor-args \"youtube:player_client=web_safari\" \\"
  echo "  --flat-playlist --skip-download \\"
  echo "  --playlist-items \"1-$SCAN\" \\"
  echo "  --print \"%(title)s\\t%(webpage_url)s\" \\"
  echo "  \"$FEED_URL\""
}

print_dry_run_cmd_for_cookies() {
  local f="$1"
  echo "yt-dlp \\"
  if (( have_deno )); then
    echo "  --js-runtimes deno \\"
  fi
  echo "  --cookies \"$f\" \\"
  echo "  --extractor-args \"youtube:player_client=web_safari\" \\"
  echo "  --flat-playlist --skip-download \\"
  echo "  --playlist-items \"1-$SCAN\" \\"
  echo "  --print \"%(title)s\\t%(webpage_url)s\" \\"
  echo "  \"$FEED_URL\""
}

print_dry_run_and_exit() {
  echo "# gyte-digest --dry-run"
  echo "browser : $BROWSER"
  echo "cookies : ${COOKIES_FILE:-}"
  echo "scan    : $SCAN"
  echo "feed    : $FEED_URL"
  echo "deno    : $have_deno"
  echo

  if [[ -n "${COOKIES_FILE:-}" ]]; then
    print_dry_run_cmd_for_cookies "$COOKIES_FILE"
    exit 0
  fi

  if [[ "$BROWSER" == "auto" ]]; then
    local b
    for b in "${SUPPORTED_BROWSERS[@]}"; do
      echo "# try browser: $b"
      print_dry_run_cmd_for_browser "$b"
      echo
    done
    exit 0
  fi

  print_dry_run_cmd_for_browser "$BROWSER"
  exit 0
}

ensure_runtime_deps() {
  need awk
  need sed
  need mkdir
  need dirname
  need mktemp
  need tail
}

prepare_workdir_and_tmp() {
  mkdir -p "$(dirname "$OUTFILE")"
  log "Auto-fetch: browser=$BROWSER cookies=${COOKIES_FILE:-} scan=$SCAN -> $OUTFILE (TSV: id<TAB>title<TAB>url)"

  TMP="$(mktemp -t gyte-digest.XXXXXX.raw)"
  CLEAN_TMP="$(mktemp -t gyte-digest.clean.XXXXXX.tsv)"
  OUT_TMP="$(mktemp -t gyte-digest.out.XXXXXX.tsv)"
  YTDLP_ERR="$(mktemp -t gyte-digest.ytdlp.XXXXXX.err)"
  trap 'rm -f "$TMP" "$CLEAN_TMP" "$OUT_TMP" "$YTDLP_ERR"' EXIT
}

# Esegue un comando e ritorna il suo rc SENZA far scattare `set -e`.
# Importante: NON stampa nulla; la gestione/log resta nel chiamante.
run_cmd_capture_rc() {
  local errexit_was_on=0
  [[ $- == *e* ]] && errexit_was_on=1

  set +e
  "$@"
  local rc=$?
  (( errexit_was_on )) && set -e

  return "$rc"
}

ytdlp_fetch() {
  local use_deno="$1"
  : >"$YTDLP_ERR"

  local -a args
  if [[ -n "${COOKIES_FILE:-}" ]]; then
    args=(
      --cookies "$COOKIES_FILE"
      --extractor-args "youtube:player_client=web_safari"
      --flat-playlist --skip-download
      --playlist-items "1-$SCAN"
      --print "%(title)s\t%(webpage_url)s"
      "$FEED_URL"
    )
  else
    args=(
      --cookies-from-browser "$BROWSER"
      --extractor-args "youtube:player_client=web_safari"
      --flat-playlist --skip-download
      --playlist-items "1-$SCAN"
      --print "%(title)s\t%(webpage_url)s"
      "$FEED_URL"
    )
  fi
  (( use_deno )) && args=( --js-runtimes deno "${args[@]}" )

  run_cmd_capture_rc yt-dlp "${args[@]}" >"$TMP" 2>"$YTDLP_ERR"
  local rc=$?

  (( VERBOSE )) && [[ -s "$YTDLP_ERR" ]] && cat "$YTDLP_ERR" >&2
  return "$rc"
}

cookie_decrypt_hint_if_needed() {
  [[ -s "$YTDLP_ERR" ]] || return 1
  if grep -qi 'secretstorage not available' "$YTDLP_ERR"; then
    echo "ERRORE: yt-dlp non riesce a decifrare i cookie del browser (manca il modulo Python 'secretstorage')." >&2
    echo "Fix: installa nel venv usato da yt-dlp:" >&2
    echo "  pip install secretstorage" >&2
    echo "Poi rilancia gyte-digest." >&2
    return 0
  fi
  if grep -qi 'failed to decrypt cookie' "$YTDLP_ERR"; then
    echo "ERRORE: yt-dlp non riesce a decifrare i cookie del browser (cookie cifrati / keyring)." >&2
    echo "Fix tipico su Linux (Chromium-based):" >&2
    echo "  pip install secretstorage" >&2
    echo "Se persiste: verifica keyring/Secret Service (gnome-keyring / kwallet) e profilo/sandbox del browser." >&2
    return 0
  fi
  return 1
}

unsupported_browser_hint_if_needed() {
  [[ -s "$YTDLP_ERR" ]] || return 1
  if grep -qi 'unsupported browser specified for cookies' "$YTDLP_ERR"; then
    echo "ERRORE: browser non supportato per --cookies-from-browser: \"$BROWSER\"." >&2
    echo "Hint: usa uno tra: $SUPPORTED_BROWSERS_HINT" >&2
    return 0
  fi
  return 1
}

ytdlp_err_has_unsupported_browser() {
  [[ -s "$YTDLP_ERR" ]] || return 1
  grep -qi 'unsupported browser specified for cookies' "$YTDLP_ERR"
}

print_ytdlp_error_and_exit() {
  local rc="$1" js_mode="$2"
  if unsupported_browser_hint_if_needed; then exit 1; fi

  if cookie_decrypt_hint_if_needed; then
    [[ -s "$YTDLP_ERR" ]] && {
      echo "" >&2
      echo "---- yt-dlp stderr (ultime 30 righe) ----" >&2
      tail -n 30 "$YTDLP_ERR" >&2 || true
      echo "----------------------------------------" >&2
    }
    exit 1
  fi

  echo "ERRORE: yt-dlp non è riuscito a leggere il feed subscriptions (rc=$rc)." >&2
  echo "  feed:    $FEED_URL" >&2
  if [[ -n "${COOKIES_FILE:-}" ]]; then
    echo "  cookies: $COOKIES_FILE" >&2
  else
    echo "  browser: $BROWSER" >&2
  fi
  echo "  js:      $js_mode" >&2
  echo "Hint: controlla login YouTube e lettura cookie (permessi/lock del profilo)." >&2
  [[ -s "$YTDLP_ERR" ]] && {
    echo "" >&2
    echo "---- yt-dlp stderr (ultime 30 righe) ----" >&2
    tail -n 30 "$YTDLP_ERR" >&2 || true
    echo "----------------------------------------" >&2
  }
  exit 1
}

# Tentativo singolo (con logica deno + fallback): NON fa exit.
# Ritorna rc:
#   0 -> comando riuscito (può comunque produrre 0 righe)
#   2 -> browser non supportato (da stderr yt-dlp)
#  >0 -> errore serio (caller decide)
# Side effects: aggiorna TMP/YTDLP_ERR e stampa stderr se VERBOSE=1 (come oggi).
try_fetch_with_retry_noexit() {
  local rc=0
  local js_mode="no-deno"

  if (( have_deno )); then
    js_mode="deno"
    if ytdlp_fetch 1; then rc=0; else rc=$?; fi

    if (( rc != 0 )); then
      if ytdlp_err_has_unsupported_browser; then
        echo "__JS_MODE__=$js_mode"
        return 2
      fi
      js_mode="fallback-no-deno"
      if ytdlp_fetch 0; then rc=0; else rc=$?; fi
    fi
  else
    js_mode="no-deno"
    if ytdlp_fetch 0; then rc=0; else rc=$?; fi
  fi

  echo "__JS_MODE__=$js_mode"
  return "$rc"
}

raw_lines_in_tmp() {
  awk 'END{print NR}' "$TMP" 2>/dev/null || echo 0
}

fetch_with_retry_or_die_explicit() {
  local rc=0
  local js_mode="no-deno"

  if (( have_deno )); then
    log "deno trovato: primo tentativo con --js-runtimes deno (fallback automatico se fallisce)"
    js_mode="deno"
    if ytdlp_fetch 1; then rc=0; else rc=$?; fi

    if (( rc != 0 )); then
      if grep -qi 'unsupported browser specified for cookies' "$YTDLP_ERR"; then
        true
      else
        log "primo tentativo (con deno) fallito rc=$rc: retry senza deno"
        js_mode="fallback-no-deno"
        if ytdlp_fetch 0; then rc=0; else rc=$?; fi
      fi
    fi
  else
    log "deno non trovato: eseguo senza --js-runtimes deno"
    js_mode="no-deno"
    if ytdlp_fetch 0; then rc=0; else rc=$?; fi
  fi

  if (( rc != 0 )); then
    print_ytdlp_error_and_exit "$rc" "$js_mode"
  fi

  if cookie_decrypt_hint_if_needed; then
    log "cookie decrypt warning detected"
  fi

  local raw_lines
  raw_lines="$(raw_lines_in_tmp)"
  log "yt-dlp ok: js=$js_mode raw_lines=$raw_lines"

  if (( raw_lines < 1 )); then
    if cookie_decrypt_hint_if_needed; then exit 1; fi
    echo "ERRORE: yt-dlp non ha prodotto alcuna riga dal feed subscriptions (output vuoto)." >&2
    echo "  feed:    $FEED_URL" >&2
    if [[ -n "${COOKIES_FILE:-}" ]]; then
      echo "  cookies: $COOKIES_FILE" >&2
    else
      echo "  browser: $BROWSER" >&2
    fi
    echo "  js:      $js_mode" >&2
    echo "Hint: quasi sempre NON sei loggato su YouTube nel profilo del browser indicato, oppure yt-dlp non riesce a leggere i cookie." >&2
    exit 1
  fi
}

fetch_with_retry_or_die_auto() {
  local original_browser="$BROWSER"
  local b
  local rc=0
  local js_mode="no-deno"

  for b in "${SUPPORTED_BROWSERS[@]}"; do
    BROWSER="$b"
    log "auto-browser: trying $b"

    local out
    out="$(try_fetch_with_retry_noexit)"
    js_mode="${out#*=}"

    rc=$?
    if (( rc == 2 )); then
      log "auto-browser: $b -> unsupported (skip)"
      continue
    fi

    if cookie_decrypt_hint_if_needed; then
      [[ -s "$YTDLP_ERR" ]] && {
        echo "" >&2
        echo "---- yt-dlp stderr (ultime 30 righe) ----" >&2
        tail -n 30 "$YTDLP_ERR" >&2 || true
        echo "----------------------------------------" >&2
      }
      exit 1
    fi

    if (( rc != 0 )); then
      print_ytdlp_error_and_exit "$rc" "$js_mode"
    fi

    local raw_lines
    raw_lines="$(raw_lines_in_tmp)"
    log "auto-browser: $b -> js=$js_mode raw_lines=$raw_lines"

    if (( raw_lines < 1 )); then
      log "auto-browser: $b -> output vuoto (skip)"
      continue
    fi

    log "auto-browser: SUCCESS ($b)"
    return 0
  done

  BROWSER="$original_browser"
  echo "ERRORE: nessun browser con sessione YouTube valida trovato (auto)." >&2
  echo "Hint: esegui login su YouTube in almeno uno tra: $SUPPORTED_BROWSERS_HINT" >&2
  exit 1
}

build_tsv() {
  sed -e $'s/\\t/\t/g' -e 's/\r$//' "$TMP" \
    | awk -F'\t' '
        BEGIN{OFS="\t"}
        NF>=2 {
          title=$1; url=$2;
          gsub(/\t/," ",title);
          gsub(/[[:space:]]+$/,"",title);
          gsub(/^[[:space:]]+/,"",title);
          if (title=="" || url=="") next;
          if (url ~ /\/shorts\//) next;
          if (url ~ /youtube\.com\/watch\?v=/ || url ~ /youtu\.be\//) print title, url;
        }
      ' >"$CLEAN_TMP"

  awk -F'\t' 'BEGIN{OFS="\t"; print "#id","title","url"} {id=sprintf("%03d", ++n); print id,$1,$2}' \
    "$CLEAN_TMP" >"$OUT_TMP"

  local lines
  lines="$(awk 'END{print NR}' "$OUT_TMP")"
  (( lines >= 2 )) || die "nessun elemento valido trovato nel feed (forse feed vuoto o parsing fallito)."

  mv -f "$OUT_TMP" "$OUTFILE"
}

emit_stdout() {
  if (( JSON )); then
    json_print "$OUTFILE"
  elif (( PRETTY )); then
    need tput
    auto_pretty_widths
    pretty_print "$OUTFILE" "$TITLE_W" "$URL_W"
  else
    cat "$OUTFILE"
  fi
}

main() {
  parse_args "$@"
  validate_flags

  need yt-dlp
  validate_cookies_file_or_die
  validate_browser_or_die
  detect_js_runtime

  if (( DRY_RUN )); then
    print_dry_run_and_exit
  fi

  ensure_runtime_deps
  prepare_workdir_and_tmp

  if [[ -n "${COOKIES_FILE:-}" ]]; then
    fetch_with_retry_or_die_explicit
  elif [[ "$BROWSER" == "auto" ]]; then
    fetch_with_retry_or_die_auto
  else
    fetch_with_retry_or_die_explicit
  fi

  build_tsv
  emit_stdout
}

main "$@"
