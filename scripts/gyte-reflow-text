#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat >&2 <<'EOF_USAGE'
Uso:
  gyte-reflow-text [opzioni] [inputfile]

Se inputfile e' omesso o uguale a "-", il testo viene letto da stdin.

Modalita':
  --paragraphs       Solo unione/compattazione righe in paragrafi
  --sentences        Solo split in frasi

Preset:
  --ai-friendly      Preset per pipeline AI:
                     - equivale a: --paragraphs + --sentences
                     - normalizza spazi (no doppi, no spazi prima di . , ? ! : ;)
                     - se --max-width non e' specificato, default soft a 120

Sanitizzazione:
  --strict-utf8      Valida/sanifica input come UTF-8:
                     - se trova byte invalidi, li rimuove (iconv -c) o li sostituisce (fallback Python)
                     - warning su stderr se ha ripulito qualcosa
                     - stdout sempre UTF-8 valido

Opzioni:
  --max-width N      Wrap "dolce" a N caratteri (non rompe parole; se una parola supera N, resta intera)
  --stats            Statistiche su stderr (stdout resta solo testo)
  -h, --help         Mostra questo help

Esempi:
  gyte-reflow-text input.txt > out.txt
  gyte-reflow-text --ai-friendly input.txt > out.ai.txt
  gyte-reflow-text --ai-friendly --max-width 140 input.txt > out.ai140.txt
  gyte-reflow-text --strict-utf8 input.txt > out.clean.txt
EOF_USAGE
}

err() { echo "Errore: $*" >&2; }

tmpfiles=()
cleanup() {
  for f in "${tmpfiles[@]:-}"; do
    rm -f -- "$f" 2>/dev/null || true
  done
}
trap cleanup EXIT

# --------------------------
# Parse args
# --------------------------
MODE_PAR=0
MODE_SENT=0
AI_FRIENDLY=0
STRICT_UTF8=0
MAX_WIDTH=""
STATS=0
INPUT_ARG=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    -h|--help) usage; exit 0 ;;
    --paragraphs) MODE_PAR=1; shift ;;
    --sentences) MODE_SENT=1; shift ;;
    --ai-friendly) AI_FRIENDLY=1; shift ;;
    --strict-utf8) STRICT_UTF8=1; shift ;;
    --max-width)
      [ "$#" -ge 2 ] || { err "--max-width richiede un valore N"; usage; exit 2; }
      MAX_WIDTH="$2"
      shift 2
      ;;
    --stats) STATS=1; shift ;;
    --) shift; break ;;
    -)
      if [[ -z "${INPUT_ARG:-}" ]]; then
        INPUT_ARG="-"
        shift
      else
        err "questo comando accetta al massimo un inputfile (trovati: '$INPUT_ARG' e '$1')"
        usage
        exit 1
      fi
      ;;
    -*)
      err "opzione sconosciuta: $1"
      usage
      exit 2
      ;;
    *)
      if [ -z "$INPUT_ARG" ]; then
        INPUT_ARG="$1"
        shift
      else
        err "questo comando accetta al massimo un inputfile (trovati: '$INPUT_ARG' e '$1')"
        usage
        exit 1
      fi
      ;;
  esac
done

if [ "$#" -gt 0 ]; then
  if [ -z "$INPUT_ARG" ] && [ "$#" -eq 1 ]; then
    INPUT_ARG="$1"
  else
    err "troppi argomenti"
    usage
    exit 1
  fi
fi

# Preset AI-friendly: forza paragraphs + sentences.
if [ "$AI_FRIENDLY" -eq 1 ]; then
  MODE_PAR=1
  MODE_SENT=1
  # Default soft max-width solo se non specificato
  if [ -z "$MAX_WIDTH" ]; then
    MAX_WIDTH="120"
  fi
fi

# Default compat: se non specifichi modalita', fai entrambe.
if [ "$MODE_PAR" -eq 0 ] && [ "$MODE_SENT" -eq 0 ]; then
  MODE_PAR=1
  MODE_SENT=1
fi

# valida max-width
if [ -n "$MAX_WIDTH" ]; then
  [[ "$MAX_WIDTH" =~ ^[0-9]+$ ]] || { err "--max-width deve essere un intero positivo"; exit 1; }
  [ "$MAX_WIDTH" -ge 10 ] || { err "--max-width troppo piccolo (min 10)"; exit 1; }
fi

# --------------------------
# Resolve input
# --------------------------
INPUT="/dev/stdin"
if [ -n "$INPUT_ARG" ] && [ "$INPUT_ARG" != "-" ]; then
  INPUT="$INPUT_ARG"
  [ -f "$INPUT" ] || { err "file '$INPUT' non trovato"; exit 1; }
fi

IN_FILE="$INPUT"

# Se input e' stdin e serve strict-utf8 o stats, bufferizziamo per poter validare / rileggere.
if { [ "$STATS" -eq 1 ] || [ "$STRICT_UTF8" -eq 1 ]; } && [ "$INPUT" = "/dev/stdin" ]; then
  tmp_in="$(mktemp -t gyte-reflow-in.XXXXXX)"
  tmpfiles+=("$tmp_in")
  cat > "$tmp_in"
  IN_FILE="$tmp_in"
fi

# --------------------------
# UTF-8 strict sanitization (opt-in)
# --------------------------
sanitize_utf8_if_needed() {
  local f="$1"
  if [ "$STRICT_UTF8" -ne 1 ]; then
    echo "$f"
    return 0
  fi

  # Preferisci iconv (leggero e presente quasi ovunque)
  if command -v iconv >/dev/null 2>&1; then
    # Validazione: se fallisce, ripulisci con -c e warning.
    if iconv -f UTF-8 -t UTF-8 "$f" >/dev/null 2>&1; then
      echo "$f"
      return 0
    fi
    echo "[gyte-reflow-text] warning: input non UTF-8 valido; ripulisco con iconv -c (byte invalidi rimossi)" >&2
    local cleaned
    cleaned="$(mktemp -t gyte-reflow-utf8.XXXXXX)"
    tmpfiles+=("$cleaned")
    iconv -f UTF-8 -t UTF-8 -c "$f" > "$cleaned" || true
    echo "$cleaned"
    return 0
  fi

  # Fallback: python3 (sostituisce byte invalidi con '?')
  if command -v python3 >/dev/null 2>&1; then
    echo "[gyte-reflow-text] warning: iconv non trovato; sanitizzo UTF-8 via python3 (invalid -> '?')" >&2
    local cleaned
    cleaned="$(mktemp -t gyte-reflow-utf8.XXXXXX)"
    tmpfiles+=("$cleaned")
    python3 - "$f" "$cleaned" <<'PY'
import sys

src = sys.argv[1]
dst = sys.argv[2]

data = open(src, "rb").read()
try:
  text = data.decode("utf-8", errors="strict")
  # gia' valido
  open(dst, "wb").write(data)
except UnicodeDecodeError:
  text = data.decode("utf-8", errors="replace")
  # 'replace' usa U+FFFD; qui lo rimpiazziamo con '?', come richiesto "o similar"
  text = text.replace("\ufffd", "?")
  open(dst, "wb").write(text.encode("utf-8", errors="strict"))
PY
    echo "$cleaned"
    return 0
  fi

  # Ultimo fallback: niente tool -> rifiuta (meglio esplicito)
  err "--strict-utf8 richiede 'iconv' o 'python3' nel PATH"
  exit 1
}

IN_FILE="$(sanitize_utf8_if_needed "$IN_FILE")"

# --------------------------
# Helper: build AWK programs as temp files
# --------------------------
make_awk_file() {
  local name="$1"
  local content="$2"
  local f
  f="$(mktemp -t "gyte-${name}.XXXXXX.awk")"
  tmpfiles+=("$f")
  printf '%s\n' "$content" > "$f"
  echo "$f"
}

# --------------------------
# Preprocess
# --------------------------
preprocess() {
  tr -d '\r' < "$IN_FILE" \
    | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//' \
    | sed -E 's/^"(.*)"$/\1/' \
    | sed -E \
        -e 's/&nbsp;+/ /g' \
        -e 's/&amp;/\&/g' \
        -e 's/&lt;/</g' \
        -e 's/&gt;/>/g' \
        -e 's/&quot;/"/g' \
        -e "s/&#39;/'/g"
}

# --------------------------
# Paragraph compaction
# --------------------------
paragraphs() {
  local awk_prog
  awk_prog="$(make_awk_file "reflow_paragraphs" "$(cat <<'AWK'
function rtrim(s){ sub(/[[:space:]]+$/, "", s); return s }
function ltrim(s){ sub(/^[[:space:]]+/, "", s); return s }
function normalize(s){ gsub(/[[:space:]]+/, " ", s); return rtrim(ltrim(s)) }

function strip_closers(s) {
  while (s ~ /["'\)\]\}]+$/) sub(/["'\)\]\}]+$/, "", s)
  return s
}

function tolow(s){ return tolower(s) }

function is_abbrev_end(s, t) {
  t = tolow(strip_closers(s))

  if (t ~ /(^|[[:space:]])(prof|dott|dr|ing|avv|sig|sig\.ra|sig\.na|ecc|es|mr|mrs|ms|jr|sr|etc|vs|no|nr|n)\.$/) return 1
  if (t ~ /(^|[[:space:]])(e\.g|i\.e)\.$/) return 1
  if (t ~ /(^|[[:space:]])(s\.p\.a|s\.r\.l|s\.n\.c)\.$/) return 1
  if (t ~ /(^|[[:space:]])([a-z]\.){2,}$/) return 1

  return 0
}

function is_sentence_end(s) {
  if (s !~ /[.!?]["'\)\]\}]*$/) return 0
  if (is_abbrev_end(s)) return 0
  return 1
}

BEGIN { par="" }
{
  line=$0
  if (line ~ /^[[:space:]]*$/) {
    if (par != "") { print par; print ""; par="" }
    next
  }
  line = normalize(line)
  if (line == "") next

  if (par == "") {
    par = line
  } else {
    if (is_sentence_end(par)) {
      print par
      par = line
    } else {
      par = par " " line
    }
  }
}
END { if (par != "") print par }
AWK
)")"
  awk -f "$awk_prog"
}

# --------------------------
# Sentence splitting (smarter)
# --------------------------
sentences() {
  local awk_prog
  awk_prog="$(make_awk_file "reflow_sentences" "$(cat <<'AWK'
function trim(s){ sub(/^[[:space:]]+/, "", s); sub(/[[:space:]]+$/, "", s); return s }
function emit(s){ s=trim(s); if (s!="") print s }

function protect_numeric_dots(s, placeholder, dotpos, p) {
  while (match(s, /[0-9]\.[0-9]/)) {
    dotpos = RSTART + 1
    s = substr(s, 1, dotpos-1) placeholder substr(s, dotpos+1)
  }
  while (match(s, /[A-Za-z][0-9]*\.[0-9]/)) {
    p = substr(s, RSTART, RLENGTH)
    dotpos = index(p, ".")
    if (dotpos > 0) {
      dotpos = RSTART + dotpos - 1
      s = substr(s, 1, dotpos-1) placeholder substr(s, dotpos+1)
    } else {
      break
    }
  }
  return s
}

function protect_token_dots(s, token, placeholder, pos, pre, mid, post) {
  while ((pos = index(s, token)) > 0) {
    pre  = substr(s, 1, pos-1)
    mid  = substr(s, pos, length(token))
    post = substr(s, pos + length(token))
    gsub(/\./, placeholder, mid)
    s = pre mid post
  }
  return s
}

function protect_abbrevs(s, placeholder, i) {
  n = 0
  toks[++n] = "Prof."; toks[++n] = "prof."
  toks[++n] = "Dott."; toks[++n] = "dott."
  toks[++n] = "Dr."; toks[++n] = "dr."
  toks[++n] = "Ing."; toks[++n] = "ing."
  toks[++n] = "Avv."; toks[++n] = "avv."
  toks[++n] = "Sig."; toks[++n] = "sig."
  toks[++n] = "Sig.ra"; toks[++n] = "sig.ra"
  toks[++n] = "Sig.na"; toks[++n] = "sig.na"
  toks[++n] = "ecc."; toks[++n] = "Ecc."
  toks[++n] = "es."; toks[++n] = "Es."
  toks[++n] = "Mr."; toks[++n] = "mr."
  toks[++n] = "Mrs."; toks[++n] = "mrs."
  toks[++n] = "Ms."; toks[++n] = "ms."
  toks[++n] = "Jr."; toks[++n] = "jr."
  toks[++n] = "Sr."; toks[++n] = "sr."
  toks[++n] = "etc."; toks[++n] = "Etc."
  toks[++n] = "vs."; toks[++n] = "Vs."
  toks[++n] = "No."; toks[++n] = "no."
  toks[++n] = "Nr."; toks[++n] = "nr."
  toks[++n] = "n."
  toks[++n] = "e.g."; toks[++n] = "i.e."
  toks[++n] = "E.g."; toks[++n] = "I.e."
  toks[++n] = "S.p.A."; toks[++n] = "s.p.a."
  toks[++n] = "S.r.l."; toks[++n] = "s.r.l."
  toks[++n] = "S.n.c."; toks[++n] = "s.n.c."
  toks[++n] = "U.S."; toks[++n] = "u.s."
  toks[++n] = "U.K."; toks[++n] = "u.k."

  for (i=1; i<=n; i++) {
    s = protect_token_dots(s, toks[i], placeholder)
  }
  return s
}

function restore_placeholder(s, placeholder) {
  gsub(placeholder, ".", s)
  return s
}

BEGIN { placeholder="__GYTEDOT__" }
{
  line=$0
  if (line ~ /^[[:space:]]*$/) { print ""; next }

  line = trim(line)
  gsub(/[[:space:]]+/, " ", line)

  line = protect_numeric_dots(line, placeholder)
  line = protect_abbrevs(line, placeholder)

  while (match(line, /[.!?]["'\)\]\}]*[[:space:]]+/)) {
    endpos = RSTART + RLENGTH - 1
    chunk = substr(line, 1, endpos)
    sub(/[[:space:]]+$/, "", chunk)

    tmp = trim(chunk)
    while (tmp ~ /["'\)\]\}]+$/) sub(/["'\)\]\}]+$/, "", tmp)

    if (tmp ~ /^[0-9]{1,3}\.$/ || tmp ~ /^[A-Za-z]\.$/) {
      sub(/[[:space:]]+$/, " ", chunk)
      rest = substr(line, endpos + 1)
      rest = trim(rest)
      line = chunk rest
      continue
    }

    chunk = restore_placeholder(chunk, placeholder)
    emit(chunk)

    line = substr(line, endpos + 1)
    line = trim(line)
  }

  line = restore_placeholder(line, placeholder)
  emit(line)
}
AWK
)")"
  awk -f "$awk_prog"
}

wrap_max_width() {
  local w="$1"
  awk -v W="$w" '
    function flush_line(){ if (out!="") { print out; out="" } }
    {
      if ($0 ~ /^[[:space:]]*$/) { flush_line(); print ""; next }

      n=split($0, a, /[[:space:]]+/)
      out=""

      for (i=1; i<=n; i++) {
        word=a[i]
        if (word=="") continue

        if (out=="") {
          out=word
        } else if (length(out) + 1 + length(word) > W) {
          print out
          out=word
        } else {
          out=out " " word
        }
      }

      flush_line()
    }
  '
}

ai_friendly_normalize_spaces() {
  # - collassa whitespace
  # - rimuove spazi prima di . , ? ! : ;
  # - trim ai bordi
  sed -E \
    -e 's/[[:space:]]+/ /g' \
    -e 's/ ([\.\,\?\!\:\;])/\1/g' \
    -e 's/^[[:space:]]+//; s/[[:space:]]+$//'
}

run_pipeline_to_file_or_stream() {
  local out_file="${1:-}"
  local do_wrap=0
  [ -n "$MAX_WIDTH" ] && do_wrap=1

  if [ -n "$out_file" ]; then
    : > "$out_file"

    if [ "$MODE_PAR" -eq 1 ] && [ "$MODE_SENT" -eq 1 ]; then
      preprocess | paragraphs | sentences > "$out_file"
    elif [ "$MODE_PAR" -eq 1 ]; then
      preprocess | paragraphs > "$out_file"
    else
      preprocess | sentences > "$out_file"
    fi

    if [ "$AI_FRIENDLY" -eq 1 ]; then
      tmp_norm="$(mktemp -t gyte-reflow-norm.XXXXXX)"
      tmpfiles+=("$tmp_norm")
      ai_friendly_normalize_spaces < "$out_file" > "$tmp_norm"
      mv -- "$tmp_norm" "$out_file"
    fi

    if [ "$do_wrap" -eq 1 ]; then
      tmp_wrapped="$(mktemp -t gyte-reflow-wrap.XXXXXX)"
      tmpfiles+=("$tmp_wrapped")
      wrap_max_width "$MAX_WIDTH" < "$out_file" > "$tmp_wrapped"
      mv -- "$tmp_wrapped" "$out_file"
    fi
  else
    if [ "$MODE_PAR" -eq 1 ] && [ "$MODE_SENT" -eq 1 ]; then
      if [ "$AI_FRIENDLY" -eq 1 ]; then
        if [ "$do_wrap" -eq 1 ]; then
          preprocess | paragraphs | sentences | ai_friendly_normalize_spaces | wrap_max_width "$MAX_WIDTH"
        else
          preprocess | paragraphs | sentences | ai_friendly_normalize_spaces
        fi
      else
        if [ "$do_wrap" -eq 1 ]; then
          preprocess | paragraphs | sentences | wrap_max_width "$MAX_WIDTH"
        else
          preprocess | paragraphs | sentences
        fi
      fi
    elif [ "$MODE_PAR" -eq 1 ]; then
      if [ "$AI_FRIENDLY" -eq 1 ]; then
        if [ "$do_wrap" -eq 1 ]; then
          preprocess | paragraphs | ai_friendly_normalize_spaces | wrap_max_width "$MAX_WIDTH"
        else
          preprocess | paragraphs | ai_friendly_normalize_spaces
        fi
      else
        if [ "$do_wrap" -eq 1 ]; then
          preprocess | paragraphs | wrap_max_width "$MAX_WIDTH"
        else
          preprocess | paragraphs
        fi
      fi
    else
      if [ "$AI_FRIENDLY" -eq 1 ]; then
        if [ "$do_wrap" -eq 1 ]; then
          preprocess | sentences | ai_friendly_normalize_spaces | wrap_max_width "$MAX_WIDTH"
        else
          preprocess | sentences | ai_friendly_normalize_spaces
        fi
      else
        if [ "$do_wrap" -eq 1 ]; then
          preprocess | sentences | wrap_max_width "$MAX_WIDTH"
        else
          preprocess | sentences
        fi
      fi
    fi
  fi
}

if [ "$STATS" -eq 1 ]; then
  tmp_out="$(mktemp -t gyte-reflow-out.XXXXXX)"
  tmpfiles+=("$tmp_out")

  run_pipeline_to_file_or_stream "$tmp_out"

  in_lines=$(wc -l < "$IN_FILE" | tr -d ' ')
  out_lines=$(wc -l < "$tmp_out" | tr -d ' ')

  avg_len=$(awk '
    $0!="" { sum+=length($0); n++ }
    END { if (n==0) print 0; else printf("%.1f", sum/n) }
  ' < "$tmp_out")

  echo "[gyte-reflow-text] input_lines=$in_lines output_lines=$out_lines avg_output_line_len=$avg_len" >&2
  cat "$tmp_out"
else
  run_pipeline_to_file_or_stream ""
fi
