#!/usr/bin/env bash
set -euo pipefail

# Uso:
#   gyte-reflow-text input.txt  > output.txt
#   cat input.txt | gyte-reflow-text > output.txt
#
# Se non specifichi il file o passi "-", legge da stdin.

usage() {
  cat >&2 << 'EOF'
Uso:
  gyte-reflow-text [inputfile]

Se inputfile Ã¨ omesso o uguale a "-", il testo viene letto da stdin.

Esempi:
  gyte-reflow-text input.txt > output.txt
  cat input.txt | gyte-reflow-text > output.txt
EOF
}

# Gestione argomenti:
# - 0 argomenti      -> usa stdin
# - 1 argomento      -> file di input o "-"
# - -h / --help      -> mostra usage
# - qualsiasi altro  -> errore esplicito
if [[ "${1-}" == "-h" || "${1-}" == "--help" ]]; then
  usage
  exit 0
elif [ "$#" -gt 1 ]; then
  echo "Errore: questo comando accetta al massimo un argomento (inputfile)." >&2
  usage
  exit 1
fi

if [ "$#" -eq 0 ] || [ "${1:-}" = "-" ]; then
  INPUT="/dev/stdin"
else
  INPUT="$1"
  if [ ! -f "$INPUT" ]; then
    echo "Errore: file '$INPUT' non trovato." >&2
    exit 1
  fi
fi

# Normalizzazione CRLF, decodifica HTML di base, merge righe, normalizzazione spazi
tr -d '\r' < "$INPUT" \
  | sed 's/^"//; s/"$//' \
  | sed -E \
      -e 's/&nbsp;+/ /g' \
      -e 's/&amp;/\&/g' \
      -e 's/&lt;/</g' \
      -e 's/&gt;/>/g' \
      -e 's/&quot;/"/g' \
      -e 's/&#39;/'"'"'/g' \
  | awk '
    BEGIN { par = "" }
    {
      # Riga vuota => chiude paragrafo
      if ($0 ~ /^[[:space:]]*$/) {
        if (par != "") {
          print par
          print ""
          par = ""
        }
      } else {
        # Riga non vuota: accumula nel paragrafo corrente
        gsub(/[[:space:]]+/, " ", $0)
        if (par == "") par = $0
        else par = par " " $0
      }
    }
    END {
      if (par != "") print par
    }
  ' \
  | sed -E 's/[[:space:]]+/ /g' \
  | sed -E 's/([.!?])\s*/\1\n/g'
