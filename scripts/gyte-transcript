#!/usr/bin/env bash
set -euo pipefail

# Uso:
#   gyte-transcript [--outdir DIR] URL_YOUTUBE [ALTRI_ARG_YT_DLP...]
#
# Directory di output:
#   GYTE_OUTDIR="/percorso" gyte-transcript URL
#   gyte-transcript --outdir "/percorso" URL
#   Priorità: --outdir > GYTE_OUTDIR > cwd
#
# Lingue preferite (in ordine) tramite env:
#   YT_TRANSCRIPT_LANGS="it,en"   (default)
#   YT_TRANSCRIPT_LANGS="en"      (solo inglese)
#   YT_TRANSCRIPT_LANGS="fr,en"   (francese con fallback su en)
#   YT_TRANSCRIPT_LANGS="auto"    (sceglie automaticamente la lingua migliore
#                                   basandosi su yt-dlp -J: subtitles/automatic_captions + language/original_language)
#
# Modalità silenziosa (yt-dlp):
#   GYTE_YTDLP_QUIET=1  -> passa -q --no-warnings a yt-dlp
#
# Formati generati:
#   - .txt  : transcript pulito
#   - .srt  : da .vtt → reformatting timestamp in stile SRT
#   - .md   : Markdown, un file per video (stesso basename del .txt)

usage() {
  cat >&2 << 'EOF'
Uso:
  gyte-transcript [--outdir DIR] URL_YOUTUBE [ALTRI_ARG_YT_DLP...]

Esempi:
  gyte-transcript "https://www.youtube.com/watch?v=XXXX"
  gyte-transcript --outdir "transcripts" "https://www.youtube.com/watch?v=XXXX"
  GYTE_OUTDIR="transcripts" gyte-transcript "https://www.youtube.com/watch?v=XXXX"

Note:
  - YT_TRANSCRIPT_LANGS controlla l'ordine delle lingue preferite (es. "it,en").
  - YT_TRANSCRIPT_LANGS=auto seleziona la lingua usando yt-dlp -J (niente indovinelli).
  - GYTE_YTDLP_QUIET=1 abilita modalità quiet per yt-dlp.
EOF
}

# --------------------------
# Gestione --outdir / GYTE_OUTDIR
# --------------------------
OUTDIR="${GYTE_OUTDIR:-.}"

# Parsing opzioni iniziali
while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --outdir)
      if [ $# -lt 2 ]; then
        echo "Errore: --outdir richiede un argomento" >&2
        exit 2
      fi
      OUTDIR="$2"
      shift 2
      ;;
    --outdir=*)
      OUTDIR="${1#--outdir=}"
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
  esac
done

if [ $# -lt 1 ]; then
  echo "Uso: $0 [--outdir DIR] URL_YOUTUBE [ALTRI_ARG_YT_DLP...]" >&2
  exit 1
fi

URL="$1"
shift || true

if [ -z "$URL" ]; then
  echo "ERRORE: URL YouTube mancante." >&2
  exit 2
fi

if [[ "$URL" == -* ]]; then
  echo "Errore: l'URL non può iniziare con '-' (forse hai invertito ordine argomenti?)." >&2
  exit 1
fi

if [[ "$URL" != http://* && "$URL" != https://* ]]; then
  echo "Errore: URL non valido (deve iniziare con http:// o https://): '$URL'" >&2
  exit 1
fi

if ! command -v yt-dlp >/dev/null 2>&1; then
  echo "Errore: 'yt-dlp' non trovato nel PATH. Installalo prima di usare gyte-transcript." >&2
  exit 1
fi

mkdir -p "$OUTDIR"
if ! cd "$OUTDIR"; then
  echo "Errore: impossibile entrare nella directory di output: $OUTDIR" >&2
  exit 1
fi

LANGS_RAW="${YT_TRANSCRIPT_LANGS:-it,en}"
QUIET_FLAG="${GYTE_YTDLP_QUIET:-0}"

echo ">> Output directory: $(pwd)"

# --------------------------
# YT_TRANSCRIPT_LANGS=auto
# --------------------------
_pick_lang_auto() {
  local url="$1"

  if ! command -v python3 >/dev/null 2>&1; then
    echo ""
    return 0
  fi

  python3 - "$url" <<'PY'
import json, subprocess, sys

url = sys.argv[1]
try:
    raw = subprocess.check_output(
        ["yt-dlp", "-J", "--skip-download", "--no-warnings", url],
        text=True,
        stderr=subprocess.DEVNULL,
    )
except Exception:
    print("")
    raise SystemExit(0)

try:
    data = json.loads(raw)
except Exception:
    print("")
    raise SystemExit(0)

# playlist safety
if isinstance(data, dict) and data.get("_type") == "playlist" and data.get("entries"):
    for e in data["entries"]:
        if e:
            data = e
            break

if not isinstance(data, dict):
    print("")
    raise SystemExit(0)

subs = data.get("subtitles") or {}
autos = data.get("automatic_captions") or {}
audio = (data.get("language") or data.get("original_language") or "").strip()

def keys(d):
    return sorted([k for k in d.keys() if k and k != "live_chat"])

def pick(d):
    ks = keys(d)
    if not ks:
        return ""
    # exact audio
    if audio and audio in d:
        return audio
    # base audio (en-US -> en)
    if audio and ("-" in audio or "_" in audio):
        base = audio.replace("_","-").split("-")[0]
        if base in d:
            return base
    # prefer *-orig if exists
    for k in ks:
        if k.endswith("-orig") or k.endswith("_orig") or k.endswith(".orig"):
            if not audio or k.startswith(audio):
                return k
    # prefix match
    if audio:
        base = audio.replace("_","-").split("-")[0]
        for k in ks:
            if k == audio or k.startswith(audio+"-") or k.startswith(audio+"_"):
                return k
        for k in ks:
            if k == base or k.startswith(base+"-") or k.startswith(base+"_"):
                return k
    # deterministic fallback
    return ks[0]

lang = pick(subs) or pick(autos) or ""
print(lang)
PY
}

langs_trimmed="${LANGS_RAW//[[:space:]]/}"
if [[ "${langs_trimmed,,}" == "auto" ]]; then
  if ! command -v python3 >/dev/null 2>&1; then
    echo "Errore: YT_TRANSCRIPT_LANGS=auto richiede python3 nel PATH." >&2
    exit 1
  fi
  auto_lang="$(_pick_lang_auto "$URL")"
  auto_lang="${auto_lang//[[:space:]]/}"
  if [[ -z "$auto_lang" ]]; then
    echo ">> [WARN] auto: nessuna lingua sottotitoli rilevata via yt-dlp -J (subtitles/automatic_captions vuoti o fallimento)." >&2
    LANGS_ARR=()
    LANGS_RAW=""
  else
    echo ">> auto: lingua selezionata = $auto_lang" >&2
    LANGS_RAW="$auto_lang"
    LANGS_ARR=("$auto_lang")
  fi
else
  echo ">> Scarico sottotitoli (ordine preferenze: $LANGS_RAW) da: $URL"
  IFS=',' read -r -a LANGS_ARR <<< "$LANGS_RAW"
fi

echo ">> Scarico sottotitoli (ordine preferenze: ${LANGS_RAW:-<nessuna>}) da: $URL"

# Config file opzionali per yt-dlp
COMMON_CONF="$HOME/.config/yt-dlp/common.conf"
PROFILE_CONF="$HOME/.config/yt-dlp/profile-transcript.conf"

yt_dlp_base_args=()

if [ -f "$COMMON_CONF" ]; then
  yt_dlp_base_args+=(--config-locations "$COMMON_CONF")
else
  echo ">> [INFO] common.conf non trovato in $COMMON_CONF (ok, procedo senza)" >&2
fi

if [ -f "$PROFILE_CONF" ]; then
  yt_dlp_base_args+=(--config-locations "$PROFILE_CONF")
else
  echo ">> [INFO] profile-transcript.conf non trovato in $PROFILE_CONF (ok, procedo senza)" >&2
fi

yt_dlp_base_args+=(
  --skip-download
  --convert-subs vtt
  --extractor-args "youtube:player_client=default"
  --no-embed-subs
  -o "%(uploader)s - %(title).80s [%(id)s].%(ext)s"
)

if [ "$QUIET_FLAG" = "1" ]; then
  yt_dlp_base_args+=(-q --no-warnings)
  echo ">> [INFO] Modalità quiet attiva per yt-dlp (GYTE_YTDLP_QUIET=1)" >&2
elif [ "$QUIET_FLAG" != "0" ]; then
  echo ">> [WARN] GYTE_YTDLP_QUIET ha un valore non riconosciuto ('$QUIET_FLAG'), uso modalità standard." >&2
fi

# Hardening argomenti extra passati a yt-dlp
safe_extra_args=()
while (("$#")); do
  arg="$1"
  shift
  case "$arg" in
    --exec|--exec=*|\
    --exec-before-download|--exec-before-download=*|\
    --exec-after-download|--exec-after-download=*|\
    --run-postprocessor|--run-postprocessor=*|\
    --postprocessor-args|--postprocessor-args=* )
      echo "Errore: opzione yt-dlp non consentita in gyte-transcript: $arg" >&2
      exit 1
      ;;
    *)
      safe_extra_args+=("$arg")
      ;;
  esac
done

success=0
attempt_index=0

for lang in "${LANGS_ARR[@]:-}"; do
  lang_trim="${lang//[[:space:]]/}"
  [ -z "$lang_trim" ] && continue

  attempt_index=$((attempt_index + 1))
  echo ">> Provo lingua: $lang_trim"

  vtt_before_lang=$(find . -maxdepth 1 -type f -name '*.vtt' | wc -l)

  if yt-dlp \
    "${yt_dlp_base_args[@]}" \
    --write-sub \
    --sub-langs "$lang_trim" \
    "$URL" \
    "${safe_extra_args[@]}"
  then
    vtt_after_lang=$(find . -maxdepth 1 -type f -name '*.vtt' | wc -l)
    if [ "$vtt_after_lang" -gt "$vtt_before_lang" ]; then
      success=1
      echo ">> Sottotitoli 'normali' scaricati con successo per lingua: $lang_trim"
      break
    else
      echo ">> [WARN] exit 0 ma nessun .vtt nuovo per '$lang_trim' (subs normali)." >&2
    fi
  else
    rc=$?
    echo ">> [WARN] Nessun sottotitolo 'normale' per '$lang_trim' (exit $rc)" >&2
  fi

  echo ">> [INFO] Provo auto-sub per lingua: $lang_trim" >&2
  vtt_before_lang_auto=$(find . -maxdepth 1 -type f -name '*.vtt' | wc -l)

  if yt-dlp \
    "${yt_dlp_base_args[@]}" \
    --write-auto-sub \
    --sub-langs "$lang_trim" \
    "$URL" \
    "${safe_extra_args[@]}"
  then
    vtt_after_lang_auto=$(find . -maxdepth 1 -type f -name '*.vtt' | wc -l)
    if [ "$vtt_after_lang_auto" -gt "$vtt_before_lang_auto" ]; then
      success=1
      echo ">> [WARN] Solo auto-sub disponibili per '$lang_trim'." >&2
      break
    else
      echo ">> [WARN] exit 0 ma nessun .vtt nuovo per '$lang_trim' (auto-sub)." >&2
    fi
  else
    rc=$?
    echo ">> [WARN] nemmeno auto-sub per '$lang_trim' (exit $rc)" >&2
  fi
done

if [ "$success" -eq 0 ]; then
  echo "⚠️  Attenzione: yt-dlp non è riuscito a scaricare sottotitoli (normali né auto-sub) per (${LANGS_RAW:-<nessuna>})." >&2
  echo '      Suggerimento: YT_TRANSCRIPT_LANGS="en,en-orig" gyte-transcript "<URL_YT>"' >&2
fi

echo ">> Pulizia file .vtt -> .txt/.srt/.md (se presenti)..."

for f in *.vtt; do
  [ -e "$f" ] || continue

  base_no_vtt="${f%.vtt}"
  txt_out="${base_no_vtt}.txt"
  srt_out="${base_no_vtt}.srt"
  md_out="${base_no_vtt}.md"

  sed -E \
    -e '/^WEBVTT/d' \
    -e '/^Kind:/d' \
    -e '/^Language:/d' \
    -e '/^NOTE/d' \
    -e '/-->/d' \
    -e '/^[0-9]+$/d' \
    -e 's/<[^>]+>//g' \
    -e 's/^[[:space:]]+//; s/[[:space:]]+$//' \
    -e '/^[[:space:]]*$/d' \
    "$f" \
  | awk 'prev != $0 { if ($0 != "") print; prev = $0 }' \
  > "$txt_out"

  awk '
    BEGIN { idx=0; in_note=0 }
    /^WEBVTT/ { next }
    /^Kind:/ { next }
    /^Language:/ { next }
    /^NOTE/ { in_note=1; next }
    in_note && NF==0 { in_note=0; next }
    in_note { next }
    /^[[:space:]]*$/ { print ""; next }
    /^[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}[[:space:]]+-->[[:space:]]+[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}/ {
      idx++
      n=split($0,a,/[[:space:]]+/)
      start=a[1]; arrow=a[2]; end=a[3]
      gsub(/\./,",",start); gsub(/\./,",",end)
      print idx
      print start " " arrow " " end
      next
    }
    { print }
  ' "$f" > "$srt_out"

  {
    printf "# %s\n\n" "$(basename "$base_no_vtt")"
    cat "$txt_out"
    printf "\n"
  } > "$md_out"

  rm -- "$f"
done
