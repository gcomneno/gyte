#!/usr/bin/env bash
set -euo pipefail

# Uso:
#   gyte-transcript [--outdir DIR] URL_YOUTUBE [ALTRI_ARG_YT_DLP...]
#
# Directory di output:
#   GYTE_OUTDIR="/percorso" gyte-transcript URL
#   gyte-transcript --outdir "/percorso" URL
#   Priorità: --outdir > GYTE_OUTDIR > cwd
#
# Lingue preferite (in ordine) tramite env:
#   YT_TRANSCRIPT_LANGS="it,en"   (default)
#   YT_TRANSCRIPT_LANGS="en"      (solo inglese)
#   YT_TRANSCRIPT_LANGS="fr,en"   (francese con fallback su en)
#
# Modalità silenziosa (yt-dlp):
#   GYTE_YTDLP_QUIET=1  -> passa -q --no-warnings a yt-dlp
#
# Formati generati:
#   - .txt  : transcript pulito (come in versione precedente)
#   - .srt  : da .vtt → reformatting timestamp in stile SRT
#   - .md   : Markdown, un file per video (stesso basename del .txt)

# --------------------------
# Gestione --outdir / GYTE_OUTDIR
# --------------------------
OUTDIR="${GYTE_OUTDIR:-.}"

while [ $# -gt 0 ]; do
  case "$1" in
    --outdir)
      if [ $# -lt 2 ]; then
        echo "Errore: --outdir richiede un argomento" >&2
        exit 2
      fi
      OUTDIR="$2"
      shift 2
      ;;
    --outdir=*)
      OUTDIR="${1#--outdir=}"
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      # Primo argomento non-opzione -> presumiamo sia la URL
      break
      ;;
  esac
done

if [ $# -lt 1 ]; then
  echo "Uso: $0 [--outdir DIR] URL_YOUTUBE [ALTRI_ARG_YT_DLP...]" >&2
  exit 1
fi

URL="$1"
shift || true

if [ -z "$URL" ]; then
  echo "ERRORE: URL YouTube mancante." >&2
  echo "Uso: gyte-transcript [--outdir DIR] <URL YouTube>" >&2
  exit 2
fi

mkdir -p "$OUTDIR"
cd "$OUTDIR"

LANGS_RAW="${YT_TRANSCRIPT_LANGS:-it,en}"
QUIET_FLAG="${GYTE_YTDLP_QUIET:-0}"

echo ">> Output directory: $OUTDIR"
echo ">> Scarico sottotitoli (ordine preferenze: $LANGS_RAW) da: $URL"

# Config file opzionali per yt-dlp
COMMON_CONF="$HOME/.config/yt-dlp/common.conf"
PROFILE_CONF="$HOME/.config/yt-dlp/profile-transcript.conf"

yt_dlp_base_args=()

if [ -f "$COMMON_CONF" ]; then
  yt_dlp_base_args+=(--config-locations "$COMMON_CONF")
else
  echo ">> [INFO] common.conf non trovato in $COMMON_CONF (ok, procedo senza)" >&2
fi

if [ -f "$PROFILE_CONF" ]; then
  yt_dlp_base_args+=(--config-locations "$PROFILE_CONF")
else
  echo ">> [INFO] profile-transcript.conf non trovato in $PROFILE_CONF (ok, procedo senza)" >&2
fi

# Opzioni "solo sottotitoli" sempre applicate,
# così lo script è autosufficiente anche senza config esterni.
yt_dlp_base_args+=(
  --skip-download          # niente video/audio
  --no-embed-subs          # nessun embed (tanto non c’è video)
  -o "%(uploader)s - %(title).80s [%(id)s].%(ext)s"
)

# Modalità quiet opzionale
if [ "$QUIET_FLAG" = "1" ]; then
  yt_dlp_base_args+=(
    -q            # quiet: solo errori
    --no-warnings # niente WARN
  )
  echo ">> [INFO] Modalità quiet attiva per yt-dlp (GYTE_YTDLP_QUIET=1)" >&2
fi

# Split delle lingue su virgola
IFS=',' read -r -a LANGS_ARR <<< "$LANGS_RAW"

success=0
attempt_index=0

for lang in "${LANGS_ARR[@]}"; do
  # trim spazi
  lang_trim="${lang//[[:space:]]/}"
  [ -z "$lang_trim" ] && continue

  attempt_index=$((attempt_index + 1))
  echo ">> Provo lingua: $lang_trim"

  #
  # 1) Tentativo sottotitoli "normali"
  #
  if yt-dlp \
    "${yt_dlp_base_args[@]}" \
    --write-sub \
    --sub-langs "$lang_trim" \
    "$URL" "$@"
  then
    success=1
    if [ "$attempt_index" -gt 1 ]; then
      echo ">> [INFO] Fallback lingua: $lang_trim (le lingue precedenti non avevano sottotitoli 'normali')" >&2
    fi
    echo ">> Sottotitoli 'normali' scaricati con successo per lingua: $lang_trim"
    break
  else
    rc=$?
    echo ">> [WARN] Nessun sottotitolo 'normale' per lingua '$lang_trim' (yt-dlp exit $rc)" >&2
  fi

  #
  # 2) Fallback auto-sub
  #
  echo ">> [INFO] Provo auto-sub per lingua: $lang_trim" >&2
  if yt-dlp \
    "${yt_dlp_base_args[@]}" \
    --write-auto-sub \
    --sub-langs "$lang_trim" \
    "$URL" "$@"
  then
    success=1
    if [ "$attempt_index" -gt 1 ]; then
      echo ">> [INFO] Fallback lingua: $lang_trim (solo auto-sub disponibili, lingue precedenti fallite)" >&2
    fi
    echo ">> [WARN] Solo auto-sub disponibili per lingua '$lang_trim' (nessun sottotitolo 'normale')" >&2
    break
  else
    rc=$?
    echo ">> [WARN] yt-dlp non ha scaricato nemmeno auto-sub per lingua '$lang_trim' (exit $rc)" >&2
  fi
done

if [ "$success" -eq 0 ]; then
  echo "⚠️  Attenzione: yt-dlp non è riuscito a scaricare sottotitoli (normali né auto-sub) per nessuna delle lingue ($LANGS_RAW)." >&2
  echo "    Controlla se il video ha sottotitoli oppure prova a impostare, ad es.:" >&2
  echo '      YT_TRANSCRIPT_LANGS="en" gyte-transcript "<URL_YT>"' >&2
fi

echo ">> Pulizia file .vtt -> .txt/.srt/.md (se presenti)..."

for f in *.vtt; do
  [ -e "$f" ] || continue

  base_no_vtt="${f%.vtt}"     # es: "Uploader - Titolo [ID].en"
  txt_out="${base_no_vtt}.txt"
  srt_out="${base_no_vtt}.srt"
  md_out="${base_no_vtt}.md"

  # 1) .txt pulito (logica precedente, invariata)
  sed -E \
    -e '/^WEBVTT/d' \
    -e '/^Kind:/d' \
    -e '/^Language:/d' \
    -e '/^NOTE/d' \
    -e '/-->/d' \
    -e '/^[0-9]+$/d' \
    -e 's/<[^>]+>//g' \
    -e 's/^[[:space:]]+//; s/[[:space:]]+$//' \
    -e '/^[[:space:]]*$/d' \
    "$f" \
  | awk 'prev != $0 { if ($0 != "") print; prev = $0 }' \
  > "$txt_out"

  echo "   Creato: $txt_out (da $f)"

  # 2) .srt — reformat dei timestamp in stile SRT
  awk '
    BEGIN {
      idx = 0
      in_note = 0
    }

    /^WEBVTT/ { next }              # rimuovi header
    /^Kind:/ { next }
    /^Language:/ { next }

    /^NOTE/ { in_note = 1; next }
    in_note && NF == 0 { in_note = 0; next }
    in_note { next }

    /^[[:space:]]*$/ {
      # riga vuota → separatore tra cue
      print ""
      next
    }

    # linea di timestamp VTT
    /^[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}[[:space:]]+-->[[:space:]]+[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}/ {
      idx++
      # split per prendere solo start/end, ignorando eventuali attributi extra
      n = split($0, a, /[[:space:]]+/)
      start = a[1]
      arrow = a[2]
      end = a[3]
      gsub(/\./, ",", start)
      gsub(/\./, ",", end)
      print idx
      print start " " arrow " " end
      next
    }

    {
      print
    }
  ' "$f" > "$srt_out"

  echo "   Creato: $srt_out (da $f)"

  # 3) .md — Markdown semplice per singolo video
  {
    printf "# %s\n\n" "$(basename "$base_no_vtt")"
    cat "$txt_out"
    printf "\n"
  } > "$md_out"

  echo "   Creato: $md_out (da $txt_out)"

  echo "   Elimino sorgente VTT: $f"
  rm -- "$f"
done
